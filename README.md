# UIMethods

Used: C#, WPF

School project for course Formal Methods.
User input catches regex. This regex will be converted to NFA and then DFA. The user can then test the DFA as an acceptor.

## Theory
For this project numerous theories are used. It's important to note that the automaton (N)DFA contains everything:
* Alphabet
* States
    * Startstate(s)
    * Finalstate(s)
* Transitions
    * From state
    * Symbol/epsilon
    * To state

These make up the automaton, but first you must create an automaton. For this the following theories are used:
* Shunting-Yard Algorithm
    * Concatenation for preparation
    * Creates postfix ([Reverse Polish Notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation))
* Thompson Construction
    * Iterate over postfix, creates NFA
* Equivalence NFA to DFA
    * Conversion from NFA to DFA
* Acceptor for regex
    * NFA to accept regex in this GUI

This theory will be a short summarary of the code, but will not include everything. For more explanation, check the code with commentary, consult the internet for theory or contact me.
<br/>
<br/>

## Shunting-Yard algorithm
The Shunting-Yard algorithm is used to get rid of parenthesis and arange the regex in such a way that the Thompson Construction can iterate over it from front to back. There is only one preparation to be done before the Shunting-Yard algorithm and that is concatenation. <br/>
Concatenation is normally not shown in a regex. This is because consecutive characters or regex(-parts) are already assumed concatenated if no other operators are applied. For example 'ab' is actually 'a' and 'b' concatenated. For this algorithm '?' is used as concat symbol. The concatenation algorithm won't be discussed, but it works neatly.
Take 'a(a|b)\*b' for example, in this case the concatenation algorithm creates the concatenated regex: 'a?(a|b)\*?b'. This is done because it glues all the regex parts together.
<br/>
<br/>
The Shunting-Yard algorithm creates a [postfix](https://en.wikipedia.org/wiki/Reverse_Polish_notation) where operators follow numbers. Using this the Thompson Construction can be easily executed. To get the postfix, each character of the concatenated regex is iterated over from front to back, see figure below. <br/>
In this flow diagram I want to highlight two parts: the section below the "char is ')' " and "precedence operatorStack top higher or equal to char". The first tackles a closing parenthesis case, which is a finishing regex(-part), thus every operator gets pushed until parenthesis opened is found again in stack. The second part is to handle the precedence of operators. This is very similar as to how precedence in mathematics works with '+', 'Ã—' and '^2'. The operators in question with their precedence are:

| Operator | Symbol | Precedence |
| -------- | ------ | ---------- |
| Star | * | 2 |
| Plus | + | 2 |
| Concat | ? | 1 |
| Or | \| | 0 |

This rounds up the working of the Shunting-Yard algorithm.

<br/>
<img src="shuntingyardalgoritme.jpg" alt="Shunting-Yard Algorithm in a flow diagram"/>
<br/>
<br/>

## Thompson construction
The Thompson Construction is loosely used here. The part used is to create NFA's for different scenarios. Each scenario has a different solution:
* Symbol
<br/><img src="TC-symbol.jpg" alt="Thompson construction for a symbol">
* Or-operator
<br/><img src="TC-or.jpg" alt="Thompson construction for an or-operator">
* Concatenation
<br/><img src="TC-concat.jpg" alt="Thompson construction for a concatenation">
* Star-operator
<br/><img src="TC-star.jpg" alt="Thompson construction for a star-operator">
* Plus-operator
<br/><img src="TC-plus.jpg" alt="Thompson construction for a plus operator">
<br/>

Every scenario is used in the algorithm. This algorithm iterates from front to back over the postfix and acts accordingly, as shown in the flow diagram below. 

<br/>
<img src="constructthompson.jpg" alt="Thompson construction in a flow diagram"/>
<br/>
<br/>

## Equivalence NFA to DFA
To convert the NFA generated by the Thompson Construction, methods are used to determine epsilon closures and which symbols go to which states. This all starts with the start state:
* Check for each letter in alphabet what possible go to states are (incl. epsilon)
* Add transition to this group of states and push the group of states to the stack
* Nowhere to go? To the trapstate for this symbol
* Repeat if there are (group of) states on the stack

<br/>
Lastly all states are scanned if they contain the previous final state and if so are defined final state. This is the algorithm explained in its simplest of forms possible, since on the big scale it's not that difficult. After all that, all states are ought to be renamed, which is implemented within the Automaton class.

<br/>
<br/>

## Acceptor for regex
Originally I had to use a extern library to check wether or not the regex given was valid, but since I finished my own acceptor I use mine. Only thing I didn't realise at the time was that things could get difficult. This is because my logic doesn't allow for recursion, which isn't a problem until you want to allow as much parenthesis as possible. So I chose for a way to allow n-depth of parenthesis. In the figure below my NFA is presented, which is, essentially, consistent of 3 parts: twice a regex acceptor and a part bridging them with parenthesis. This can be done n-amount of times (current implementation, n = 3). For every n + 1 the parenthesis bridge is created to a new part. After creating this logic I convert the NFA to a DFA using previous logic and you have a working regex acceptor. Only downfall being in this case that you can only have n-amount parenthesis. Still a worthy solution for the application.
<br/>
<img src="regexacceptor.jpg" alt="Regex acceptor as NFA">